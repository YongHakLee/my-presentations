<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>2025-09-17 Lab Meeting: Camera Matrix</title>

    <!-- reveal.js의 핵심 CSS 파일들을 루트 디렉토리에서 가져옵니다. -->
    <link rel="stylesheet" href="/../../reveal.js/dist/reset.css">
    <link rel="stylesheet" href="/../../reveal.js/dist/reveal.css">
    <!-- 프레젠테이션 테마 (white, black, league, sky, beige, simple, ... 등) -->
    <link rel="stylesheet" href="/../../reveal.js/dist/theme/white.css" id="theme">

    <!-- 코드 구문 강조(Highlighting)를 위한 테마 -->
    <link rel="stylesheet" href="/../../reveal.js/plugin/highlight/monokai.css">

    <style>
        /* 이미지 크기 조절을 위한 사용자 정의 스타일 */
        .img-medium {
            max-height: 500px;
            width: auto;
        }
    </style>
</head>
<body>
    <div class="reveal">
        <div class="slides">

            <section>
                <h2>2025-09-17 Lab Meeting</h2>
                <h1>Topic: Camera Matrix</h1>
            </section>

            <section>
                <h2>Introduction</h2>
                <p class="fragment">카메라 행렬(Camera Matrix)은 월드 공간(World Space)의 한 점이 어떻게 이미지에 매핑되는지를 알려줍니다.</p>
                <p class="fragment">카메라 행렬은 <strong>Intrinsic Matrix</strong>와 <strong>Extrinsic Matrix</strong>로 나뉩니다.</p>
            </section>

            <section>
                <h3>Intrinsic Matrix</h3>
                <p>카메라의 내부 파라미터를 포함하는 행렬</p>
                \[
                K = \begin{bmatrix}
                f_x & 0 & c_x \\
                0 & f_y & c_y \\
                0 & 0 & 1
                \end{bmatrix}
                \]
            </section>

            <section>
                <h3>Extrinsic Matrix</h3>
                <p>카메라의 외부 파라미터를 포함하는 행렬</p>
                <div style="display: flex; align-items: center; justify-content: space-around;">
                    <div>
                        <p>Rotation (R)</p>
                        \[
                        R = \begin{bmatrix}
                        r_{11} & r_{12} & r_{13} \\
                        r_{21} & r_{22} & r_{23} \\
                        r_{31} & r_{32} & r_{33}
                        \end{bmatrix}
                        \]
                    </div>
                    <div>
                        <p>Translation (T)</p>
                        \[
                        T = \begin{bmatrix}
                        t_x \\
                        t_y \\
                        t_z
                        \end{bmatrix}
                        \]
                    </div>
                </div>
            </section>

            <section>
                <h2>핀홀 카메라 (Pinhole Camera)</h2>
                <p>실제 카메라는 분석이 복잡하여, 우리는 <strong>핀홀 카메라</strong>라는 단순화된 모델을 사용합니다.</p>
                <p class="fragment">이상적인 핀홀 카메라는 무한히 작은 조리개(점)를 가지며, 센서의 각 점에는 단 하나의 방향에서 오는 빛만 도달합니다.</p>
                <img data-src="/imgs/pinhole_camera.png" alt="핀홀 카메라" class="img-medium fragment">
            </section>

            <section>
                <h3>핀홀 카메라 모델의 한계</h3>
                <p>실제 카메라는 렌즈 왜곡(Distortion)과 같은 오차를 발생시킵니다.</p>
                <ul>
                    <li class="fragment"><strong>방사 왜곡 (Radial Distortion)</strong>: 렌즈 중심에서 멀어질수록 이미지가 볼록/오목해지는 현상</li>
                    <li class="fragment"><strong>접선 왜곡 (Tangential Distortion)</strong>: 렌즈와 센서가 평행하지 않아 이미지가 기울어 보이는 현상</li>
                </ul>
                <p class="fragment">하지만 좋은 카메라에서는 오차가 작아, 핀홀 모델은 간단하고 매우 유용한 모델입니다.</p>
            </section>
            
            <section>
                <h2>월드와 카메라 좌표계</h2>
                <p>카메라 작업 시, 센서가 x-y축과 정렬되고 카메라는 양의 z축을 바라보는 좌표계를 사용하는 것이 일반적입니다.</p>
                <p class="fragment">z축은 <strong>광축(Optical Axis)</strong>이라고도 불립니다.</p>
                <img data-src="/imgs/camera_coordinate.png" alt="카메라 좌표계" class="img-medium fragment">
            </section>

            <section>
                <h2>내부 파라미터 행렬 (Intrinsic Matrix)</h2>
                <p>핀홀 조리개를 카메라 좌표계 원점에, 이미지 평면(센서)을 조리개 뒤에 놓습니다.</p>
                <img data-src="/imgs/sensor_aperture.png" alt="센서와 조리개" class="r-stretch">
            </section>

            <section>
                <h3>초점 거리와 화각</h3>
                <p>이미지 평면과 조리개 사이의 거리를 <strong>초점 거리(Focal Length, F)</strong>라고 합니다.</p>
                <p>포착 가능한 양 극단 광선 사이의 각도를 <strong>화각(Angle of View)</strong>이라고 합니다.</p>
                <img data-src="/imgs/angle_of_view.png" alt="수평 화각" class="r-stretch">
            </section>
            
            <section>
                <h3>투영 관계 (Projection)</h3>
                <p>점 (X, Z)에서 온 광선이 조리개를 통과하여 센서에 닿습니다. 이미지 상의 점은 -U가 됩니다.</p>
                <img data-src="/imgs/two_objects.png" alt="물체들" class="r-stretch">
            </section>

            <section>
                <h3>닮은 삼각형 원리</h3>
                <p>닮은 삼각형의 원리를 통해 다음 식을 유도할 수 있습니다.</p>
                \[ \frac{-U}{-F} = \frac{X^C}{Z^C} \]
                <p class="fragment">초점 거리(F)와 이미지 평면 크기(U)의 절대값은 중요하지 않고, 상대적인 값만이 중요합니다.</p>
            </section>
            
            <section>
                <h3>단위 변환: mm to pixel</h3>
                <p>거리를 픽셀 단위로 표현하기 위해 계수 k (pixels/mm)를 도입합니다.</p>
                <p>k = w/W (센서 너비(px) / 센서 너비(mm))</p>
                 \[ \frac{-kU}{-kF} = \frac{X^C}{Z^C} \quad \Rightarrow \quad \frac{-u}{-f_x} = \frac{X^C}{Z^C} \]
                <img data-src="/imgs/pixelwithk.png" alt="k적용" class="r-stretch">
            </section>

            <section>
                <h3>센서 오프셋 (Sensor Offset)</h3>
                <p>센서가 광축과 완벽히 정렬되지 않고 x 방향으로 $u_0$만큼 벗어난 경우를 고려합니다.</p>
                \[ -u' = -u - u_{0} \quad \Rightarrow \quad -u = -u' + u_{0} \]
                <p>최종 수식은 다음과 같습니다.</p>
                 \[ \frac{-u'+u_0}{-f_x} = \frac{X^C}{Z^C} \]
            </section>

            <section>
                <h3>최종 내부 파라미터 수식</h3>
                <p>Y 방향에 대해서도 동일하게 적용하고 정리하면,</p>
                \[ uZ^{C} = f_{x}X^{C} + u_{0}Z^{C} \]
                \[ vZ^{C} = f_{y}Y^{C} + v_{0}Z^{C} \]
                <p class="fragment">이를 행렬로 표현하면 다음과 같습니다.</p>
                \[
                \begin{bmatrix}
                Z^Cu \\
                Z^Cv 
                \end{bmatrix}=
                \begin{bmatrix}
                f_x & 0 & u_0 \\
                0 & f_y & v_0 
                \end{bmatrix}
                \begin{bmatrix}
                X^C \\
                Y^C \\
                Z^C
                \end{bmatrix}
                \]
            </section>

            <section>
                <h2>동차 좌표계 (Homogeneous)</h2>
                <p>데카르트 좌표 [x, y] → 동차 좌표 (xS, yS, S)</p>
                <div style="display: flex; justify-content: space-around;">
                    <img data-src="/imgs/homogeneous_1.png" alt="동차 좌표계1" style="max-height: 400px;">
                    <img data-src="/imgs/homogeneous_2.png" alt="동차 좌표계2" style="max-height: 400px;">
                </div>
            </section>
            
            <section>
                <h3>동차 좌표계의 장점</h3>
                <p>회전(Rotation)과 이동(Translation) 연산을 하나의 행렬 곱셈으로 통합할 수 있습니다.</p>
                <img data-src="/imgs/homogeneous_3.png" alt="동차 좌표계3" class="r-stretch">
            </section>

            <section>
                <h3>Intrinsic Matrix (동차 좌표계)</h3>
                <p>동차 좌표계를 활용하여 내부 파라미터 행렬을 3x3 행렬로 확장할 수 있습니다.</p>
                \[
                \begin{bmatrix}
                f_x & 0 & u_0 \\
                0 & f_y & v_0 \\
                0 & 0 & 1
                \end{bmatrix}
                \begin{bmatrix}
                X^C \\
                Y^C \\
                Z^C
                \end{bmatrix}=
                \begin{bmatrix}
                Z^Cu \\
                Z^Cv \\
                Z^C
                \end{bmatrix}
                \]
            </section>
            
            <section>
                <h2>외부 파라미터 행렬 (Extrinsic Matrix)</h2>
                <p>객체 좌표를 월드 좌표계(World)에서 카메라 좌표계(Camera)로 변환하는 역할을 합니다.</p>
                 \[
                \begin{bmatrix}
                X^C \\
                Y^C \\
                Z^C 
                \end{bmatrix}
                =
                \begin{bmatrix}
                r_{11} & r_{12} & r_{13} & t_x \\
                r_{21} & r_{22} & r_{23} & t_y \\
                r_{31} & r_{32} & r_{33} & t_z 
                \end{bmatrix}
                \begin{bmatrix}
                X^W \\
                Y^W \\
                Z^W \\
                1
                \end{bmatrix}
                \]
            </section>
            
            <section>
                <h3>좌표 변환 (Coordinate Transformations)</h3>
                <p><strong>좌표계를 변환</strong>하는 것은 <strong>객체의 좌표를 역방향으로 변환</strong>하는 것과 같습니다.</p>
                <p class="fragment">Camera-to-World 행렬의 역행렬은 World-to-Camera 행렬입니다.</p>
                 <img data-src="/imgs/camera_and_world_coord.png" alt="카메라와 월드좌표계" class="img-medium fragment">
            </section>
            
            <section>
                <h3>Extrinsic Matrix 예시</h3>
                <p>월드 축을 중심으로 회전 및 이동하여 카메라의 위치와 방향을 정의합니다.</p>
                 <img data-src="/imgs/real_example.png" alt="전체 예시" class="r-stretch">
            </section>

            <section>
                 <h3>Camera-to-World Matrix</h3>
                 <p>카메라 좌표를 월드 좌표로 매핑하는 행렬입니다.</p>
                 <img data-src="/imgs/camera_to_world.png" alt="camera_to_world_matrix" class="r-stretch">
            </section>

            <section>
                <h3>World-to-Camera Matrix</h3>
                <p>우리가 필요한 것은 World-to-Camera 행렬이며, 이는 Camera-to-World 행렬의 역행렬입니다.</p>
                <img data-src="/imgs/world_to_camera.png" alt="world_to_camera_matrix" class="r-stretch">
            </section>

        </div>
    </div>

    <!-- reveal.js의 핵심 JS 파일들을 루트 디렉토리에서 가져옵니다. -->
    <script src="/../../reveal.js/dist/reveal.js"></script>
    <!-- 플러그인 로드 -->
    <script src="/../../reveal.js/plugin/notes/notes.js"></script>
    <script src="/../../reveal.js/plugin/markdown/markdown.js"></script>
    <script src="/../../reveal.js/plugin/highlight/highlight.js"></script>
    <script src="/../../reveal.js/plugin/math/math.js"></script>
    <script>
        // Reveal.js 초기화 및 플러그인 활성화
        Reveal.initialize({
            hash: true,
            plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.KaTeX ]
        });
    </script>
</body>
</html>